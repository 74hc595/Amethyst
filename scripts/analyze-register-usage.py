#!/usr/bin/env python3
#
# Analyzes a set of AVR disassembly files (generated by avr-objdump) and reports
# the set of registers used (r0 through r31) by each function.
# Can be used to determine which registers are safe to reserve globally with the
# `register asm()` construct:
#  https://www.microchip.com/webdoc/AVRLibcReferenceManual/FAQ_1faq_regbind.html
# Can also be used to determine which standard library functions are safe to use
# when a given set of registers is reserved globally.
#
# TODO: command line arg parsing, this is all hardcoded

import re
import operator
import sys
from functools import reduce
from collections import defaultdict

# in this codebase, r2 through r7 are "unsafe" because they're reserved for ISRs
UNSAFE_REGS = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<7)

numbered_register_re = re.compile(r'r(\d{1,2})$')
x_register_re = re.compile(r'-?X\+?$')
y_register_re = re.compile(r'-?Y(\+\d{0,2})?$')
z_register_re = re.compile(r'-?Z(\+\d{0,2})?$')
fn_start_re = re.compile(r'[0-9a-fA-F]+ <(.+)>:$')

def recognize_numbered_register(s: str) -> int:
  match = numbered_register_re.match(s)
  if match is None:
    return 0
  else:
    reg_num = int(match.group(1))
    return 1<<reg_num if 0<=reg_num<=31 else 0

def recognize_x_register(s: str) -> int:
  match = x_register_re.match(s)
  return (0b11<<26) if match is not None else 0

def recognize_y_register(s: str) -> int:
  match = y_register_re.match(s)
  return (0b11<<28) if match is not None else 0

def recognize_z_register(s: str) -> int:
  match = z_register_re.match(s)
  return (0b11<<30) if match is not None else 0

RECOGNIZERS = (
  recognize_numbered_register,
  recognize_x_register,
  recognize_y_register,
  recognize_z_register
)

def recognize_registers_in_arg(s: str) -> int:
  return reduce(operator.__or__, (f(s) for f in RECOGNIZERS))

def recognize_registers_in_args(line: str) -> int:
  args = [s.strip() for s in line.split(',')]
  return reduce(operator.__or__, map(recognize_registers_in_arg, args))

def recognize_registers_in_line(line: str) -> int:
  try:
    addr, opcode, mnemonic, args, *comment = line.split('\t')
    return recognize_registers_in_args(args)
  except ValueError:
    return 0

def make_table_row(fnname, regs):
  cells = ['<tr class="{}"><td>{}</td>'.format('unsafe' if (regs & UNSAFE_REGS) else '', fnname)]
  cells.extend('<td>{}</td>'.format('r'+str(n) if regs & (1<<n) else '') for n in range(0,32))
  cells.append('</tr>')
  return ''.join(cells)


current_fn = None
fn_register_usage = defaultdict(int)

LST_FILES = ['libatmega1284','libgcc','libc','libm','libprintf_flt','libprintf_min','libscanf_flt','libscanf_min']
LST_SUFFIX = '_avr51.dis.lst'

for filename in LST_FILES:
  with open(filename+LST_SUFFIX, 'r') as lstfile:
    for line in lstfile:
      # does this line start a function?
      fnmatch = fn_start_re.match(line)
      if fnmatch:
        current_fn = filename + ':' + fnmatch.group(1)
      else:
        regs = recognize_registers_in_line(line)
        fn_register_usage[current_fn] |= regs

for fn, regs in fn_register_usage.items():
  if regs & UNSAFE_REGS:
    print('--wrap '+fn.split(':')[1])

# print('<html><head><style>td { border: 1px solid black; } .unsafe { color:red; }</style></head><body><table>')
# print(make_table_row('<b>library:function</b>', 0xFFFFFFFF))
# for item in fn_register_usage.items():
#   print(make_table_row(*item))
# print('</table></body></html>')